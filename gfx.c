/**********************************************************************************************************************
 * \file gfx.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <stdio.h>
#include "gfx.h"

/* PDL and board */
#include "cy_pdl.h"
#include "cybsp.h"

/* Graphics Driver */
#include "cygfx_driver_api.h"

/* Util library */
#include "sm_util.h"
#include "ut_compatibility.h"
#include "ut_disp.h"
#include "ut_disp_panels.h"
#include "ut_memman.h"
#include "ut_filter.h"
#include "pe_matrix.h"
#include "pe_drawing.h"

#include "res.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define DISPLAY_WIDTH           (800)
#define DISPLAY_HEIGHT          (480)
#define TASK_INSTR_BUFFER_SIZE  (16 * 1024)

#define STATE_COUNT             (3)

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
static CYGFX_DISP disp;
static CYGFX_BE_CONTEXT ctx;
static void* taskInstrBuffer;
static UTIL_CONTEXT utCtx;

static CYGFX_WINDOW winBG;
static CYGFX_WINDOW winOrig;
static CYGFX_WINDOW winFilter;
static CYGFX_WINDOW winText;

static CYGFX_SURFACE surfBG;
static CYGFX_SURFACE surfOrig;
static CYGFX_SURFACE surfFilter;
static CYGFX_SURFACE surfFont;
static CYGFX_SURFACE surfText;

static CYGFX_SYNC_OBJECT_S sync;

static CYGFX_U08 state = 0;
static CYGFX_U08 filterDir = 0;
static CYGFX_FLOAT sigma = 3.0f;
static CYGFX_U08 taps = 9;

static volatile CYGFX_BOOL dirty = true;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void initVideoSSInterrupts(void);
static CYGFX_ERROR initDriverAndDisplay(void);
static CYGFX_ERROR initContext(void);
static CYGFX_ERROR initTaskInstrBuffer(void);
static CYGFX_ERROR initSync(void);
static CYGFX_ERROR initSurfaces(void);
static CYGFX_ERROR initWindows(void);

static CYGFX_ERROR filterApply(const CYGFX_U08 taps, const CYGFX_FLOAT* const coefficients, 
    const CYGFX_BOOL normalize);
static CYGFX_ERROR filterBlur(void);
static CYGFX_ERROR filterSharpen(void);
static CYGFX_ERROR filterEdgeDetection(void);

static CYGFX_ERROR printInfo(char* title, const CYGFX_U08 taps, 
    const CYGFX_FLOAT sigma, const CYGFX_FLOAT* const coefficients);

static void calcGauss(CYGFX_FLOAT* const coefficients, const CYGFX_U08 taps, const CYGFX_FLOAT sigma);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: initGfx
 * Summary:
 *  Initializes all required subsystems
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
CYGFX_ERROR initGfx(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    initVideoSSInterrupts();
    UTIL_SUCCESS(ret, initDriverAndDisplay());
    UTIL_SUCCESS(ret, initContext());
    UTIL_SUCCESS(ret, initTaskInstrBuffer());
    UTIL_SUCCESS(ret, initSync());
    UTIL_SUCCESS(ret, initSurfaces());
    UTIL_SUCCESS(ret, initWindows());
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: loopGfx
 * Summary:
 *  Main graphics application. Needs to be called periodically in a loop, at least
 *  as often as the target framerate (for example for 60 FPS -> 1/60 secs = ~16.66 ms).
 *  Can be called quicker, function takes care of syncing and will immediately return
 *  if not ready yet.
 *  This function draws only something if there is a change detected by a button press.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
CYGFX_ERROR loopGfx(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    if (dirty == CYGFX_FALSE)
    {
        /* We return okay because it's normal to return here if nothing new has to be rendered */
        return CYGFX_OK;
    }
    
    /* Was the last frame rendered yet? */
    if (CyGfx_SyncWaitSync(&sync, 0) == CYGFX_ERP_ERR_SYNC_TIMEOUT)
    {
        /* We return okay because it's normal for this function to return early if previous frame not finished yet */
        return CYGFX_OK;
    }
    
    /* Dependent on state, render a different scene */
    switch (state)
    {
        case 0: UTIL_SUCCESS(ret, filterBlur()); break;
        case 1: UTIL_SUCCESS(ret, filterSharpen()); break;
        case 2: UTIL_SUCCESS(ret, filterEdgeDetection()); break;
        default: UTIL_SUCCESS(ret, filterBlur()); break;
    }
    
    /* Sync the blit engine to the display. Get a sync object in the end which indicates when frame is finished
     * and this function can be executed again. DispCommit is configured to commit all window changes at once. */
    UTIL_SUCCESS(ret, CyGfx_BeGetSync(ctx, &sync));
    UTIL_SUCCESS(ret, CyGfx_DispWaitSync(disp, &sync));
    UTIL_SUCCESS(ret, CyGfx_DispCommit(disp));
    UTIL_SUCCESS(ret, CyGfx_DispGetSync(disp, &sync));
    
    /* Drawing is finished, clear dirty field */
    dirty = CYGFX_FALSE;
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: deinitGfx
 * Summary:
 *  Deinitializes subsystems and frees memory.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
CYGFX_ERROR deinitGfx(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    /* Windows */
    UTIL_SUCCESS(ret, CyGfx_WinDestroy(winText));
    UTIL_SUCCESS(ret, CyGfx_WinDestroy(winFilter));
    UTIL_SUCCESS(ret, CyGfx_WinDestroy(winOrig));
    UTIL_SUCCESS(ret, CyGfx_WinDestroy(winBG));
    
    /* Surfaces */
    utSurfDeleteBuffer(surfText);
    UTIL_SUCCESS(ret, utSmDeleteSurfaceObjects(1, &surfText));
    utSurfDeleteBuffer(surfFont);
    UTIL_SUCCESS(ret, utSmDeleteSurfaceObjects(1, &surfFont));
    utSurfDeleteBuffer(surfFilter);
    UTIL_SUCCESS(ret, utSmDeleteSurfaceObjects(1, &surfFilter));
    utSurfDeleteBuffer(surfOrig);
    UTIL_SUCCESS(ret, utSmDeleteSurfaceObjects(1, &surfOrig));
    utSurfDeleteBuffer(surfBG);
    UTIL_SUCCESS(ret, utSmDeleteSurfaceObjects(1, &surfBG));
    
    /* Task Instruction buffers */
    utVideoFree(taskInstrBuffer);
    
    /* Contexts */
    utPeDeleteContext(ctx);
    
    /* Display */
    UTIL_SUCCESS(ret, CyGfx_DispCloseDisplay(disp));
    
    /* Driver */
    UTIL_SUCCESS(ret, CyGfx_SysDeInitializeDriver());
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: nextFilter
 * Summary:
 *  Switches to the next filter (blur->sharpen->edge).
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
void nextFilter(void)
{
    printf("Next state\r\n\n");
    state = (state + 1 > STATE_COUNT - 1) ? 0 : state + 1;    
    dirty = CYGFX_TRUE;
}

/**********************************************************************************************************************
 * Function Name: nextDirection
 * Summary:
 *  Switches to the next filter direction (both->horizontal->vertical).
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
void nextDirection(void)
{
    printf("Next kernel\r\n\n");
    filterDir = (filterDir + 1 > 2) ? 0 : filterDir + 1;
    dirty = CYGFX_TRUE;
}

/**********************************************************************************************************************
 * Function Name: nextSigma
 * Summary:
 *  Switches to the next sigma value (0.5 to 5.0 in 0.5 steps)
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
void nextSigma(void)
{
    printf("Next sigma\r\n\n");
    sigma = (sigma + 0.5f > 5.0f) ? 0.5f : sigma + 0.5f;
    dirty = CYGFX_TRUE;
}

/**********************************************************************************************************************
 * Function Name: nextTaps
 * Summary:
 *  Switches to the next taps value (3 to 15 in 2 steps)
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
void nextTaps(void)
{
    printf("Next taps\r\n\n");
    taps = (taps + 2 > 15) ? 3 : taps + 2;
    dirty = CYGFX_TRUE;
}

/**********************************************************************************************************************
 * Function Name: initVideoSSInterrupts
 * Summary:
 *  Setting up VideoSS interrupts with respective handler and enabling them in NVIC.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void initVideoSSInterrupts(void)
{
    /* VideoSS interrupts configurations */
    const cy_stc_sysint_t IRQ_VIDEOSS_GFX2D_CFG =
    {
        .intrSrc  = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_gfx2d_IRQn),
        .intrPriority = 3UL
    };

    const cy_stc_sysint_t IRQ_VIDEOSS_VIDEOIO0_CFG =
    {
        .intrSrc  = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_videoio0_IRQn),
        .intrPriority = 3UL
    };
    
    const cy_stc_sysint_t IRQ_VIDEOSS_VIDEOIO1_CFG =
    {
        .intrSrc  = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_videoio1_IRQn),
        .intrPriority = 3UL
    };

    /* Initialize VideoSS interrupts */
    if (Cy_SysInt_Init(&IRQ_VIDEOSS_GFX2D_CFG, CyGfx_kInterruptHandlerGfx2d) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    if (Cy_SysInt_Init(&IRQ_VIDEOSS_VIDEOIO0_CFG, CyGfx_kInterruptHandlerVideoio0) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    if (Cy_SysInt_Init(&IRQ_VIDEOSS_VIDEOIO1_CFG, CyGfx_kInterruptHandlerVideoio1) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    /* Enable the corresponding NVIC interrupt */
    NVIC_EnableIRQ(NvicMux3_IRQn);
}

/**********************************************************************************************************************
 * Function Name: initDriverAndDisplay
 * Summary:
 *  Initializes the driver and a 800x480 display shown via FX3. Required timings are
 *  properly setup by adjusting PLLs. Driver and display need same timing information,
 *  thus both done in the same function.
 *  DispCommit is configured to commit all windows at once.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initDriverAndDisplay(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    CYGFX_SYSINIT_INFO_S initInfo = CYGFX_SYS_INIT_INITIALIZER;
    CYGFX_DISP_PROPERTIES_S dispProps = CYGFX_DISP_PROPERTIES_INITIALIZER;
    CYGFX_U08 clockDivider;
    
    /* Use timing properties located in util library for 800x480 display */
    dispProps = s_panel_XXX_800_480;
    
    /* FX3 output is on display controller 1 */
    dispProps.outputController = CYGFX_DISP_CONTROLLER_1;
    
    /* FX3 RGB signals do not need to be remapped, thus don't use TCON */
    dispProps.pTconProps = NULL;
    dispProps.countTconProps = 0;
    
    /* Calculate PLL frequency based on pixel clock. PLL_1 is used for FX3 output */
    UTIL_SUCCESS(ret, utDispGetPll(dispProps.timing.pixelClock,
         dispProps.displayMode, &clockDivider, &initInfo.PllDsp1));
    UTIL_SUCCESS(ret, utDispEnablePll(initInfo.PllDsp1, dispProps.outputController));
    
    /* Init driver and reset memory manager */
    UTIL_SUCCESS(ret, CyGfx_SysInitializeDriver(&initInfo));
    UTIL_SUCCESS(ret, utMmanReset());
    
    /* Enable display */
    UTIL_SUCCESS(ret, CyGfx_DispOpenDisplay(&dispProps, &disp, NULL));
    
    /* Change all windows at one commit at the same time */
    UTIL_SUCCESS(ret, CyGfx_DispSetAttribute(disp, CYGFX_DISP_ATTR_INCLUDE_WIN_COMMIT, CYGFX_TRUE));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initContext
 * Summary:
 *  Initializes a context for the Blit Engine, sets origin of coordinate system
 *  to top-left of display and forces IBO mode for FIR filter.
 *  Further initializes a utility context for bitmap font rendering.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initContext(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    UTIL_SUCCESS(ret, utPeGenContext(&ctx));
    
    /* Change origin of coordinate system to the top left point of display */
    UTIL_SUCCESS(ret, CyGfx_BeSetAttribute(ctx, CYGFX_BE_CTX_ATTR_ZERO_POINT, CYGFX_BE_ATTR_ZERO_TOP_LEFT));
    
    /* FIR filter only work in IBO mode */
    UTIL_SUCCESS(ret, CyGfx_BeSetAttribute(ctx, CYGFX_BE_CTX_ATTR_RENDER_MODE, CYGFX_BE_RENDER_MODE_IBO));
    
    /* Utility context for simple bitmap font rendering */
    utResetContext(&utCtx);
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initTaskInstrBuffer
 * Summary:
 *  Allocates memory for task instruction buffer and registers it to graphics driver.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initTaskInstrBuffer(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    taskInstrBuffer = utVideoAlloc(TASK_INSTR_BUFFER_SIZE, 32, NULL);
    CY_ASSERT(taskInstrBuffer != NULL);
    UTIL_SUCCESS(ret, CyGfx_BeSetTaskInstructionBuffer(CYGFX_BE_TASK_MEM_PRIO_1, 
        taskInstrBuffer, TASK_INSTR_BUFFER_SIZE));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initSync
 * Summary:
 *  Initializes all used sync objects.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initSync(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    UTIL_SUCCESS(ret, CyGfx_SyncReset(&sync));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initSurfaces
 * Summary:
 *  Initializes all surfaces (by allocating memory, loading bitmaps, etc.).
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initSurfaces(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    /* Background, fill with black color */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(1, &surfBG));
    UTIL_SUCCESS(ret, utSurfCreateBuffer(surfBG, DISPLAY_WIDTH, DISPLAY_HEIGHT, CYGFX_SM_FORMAT_R8G8B8));
    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_STORE | CYGFX_BE_TARGET_DST, surfBG));
    UTIL_SUCCESS(ret, CyGfx_BeSetAttribute(ctx, CYGFX_BE_CTX_ATTR_COLOR, CYGFX_SM_COLOR_TO_RGBA(0, 0, 0, 255)));
    UTIL_SUCCESS(ret, CyGfx_BeFill(ctx, 0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT));
    UTIL_SUCCESS(ret, CyGfx_BeFinish(ctx));

    /* Image to be filtered */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(1, &surfOrig));
    UTIL_SUCCESS(ret, utSurfLoadBitmap(surfOrig, img_lenna, CYGFX_FALSE));

    /* Result of filter */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(1, &surfFilter));
    UTIL_SUCCESS(ret, utSurfCreateBuffer(surfFilter, utSurfWidth(surfOrig), utSurfHeight(surfOrig), CYGFX_SM_FORMAT_R8G8B8A8));

    /* Font bitmap */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(1, &surfFont));
    UTIL_SUCCESS(ret, utSurfLoadBitmap(surfFont, courier_12, CYGFX_FALSE));
    utSetFont(&utCtx, surfFont);
    utColor(&utCtx, 255, 255, 255, 255);

    /* Text */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(1, &surfText));
    UTIL_SUCCESS(ret, utSurfCreateBuffer(surfText, DISPLAY_WIDTH, DISPLAY_HEIGHT - utSurfHeight(surfOrig), CYGFX_SM_FORMAT_R8G8B8A8));
    utTarget(&utCtx, surfText);
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initWindows
 * Summary:
 *  Initializes all windows with respective properties.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initWindows(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    CYGFX_DISP_WINDOW_PROPERTIES_S winProps = CYGFX_DISP_WINDOW_PROPERTIES_INITIALIZER;
    
    winProps.width = DISPLAY_WIDTH;
    winProps.height = DISPLAY_HEIGHT;
    winProps.layerId = CYGFX_DISP_LAYER_0;
    UTIL_SUCCESS(ret, CyGfx_DispWinCreate(disp, &winProps, &winBG));
    UTIL_SUCCESS(ret, CyGfx_WinSetSurface(winBG, CYGFX_DISP_BUFF_TARGET_COLOR_BUFF, surfBG));
    
    winProps.width = utSurfWidth(surfOrig);
    winProps.height = utSurfHeight(surfOrig);
    winProps.topLeftX = 0;
    winProps.topLeftY = 0;
    winProps.layerId = CYGFX_DISP_LAYER_1;
    winProps.features = CYGFX_DISP_FEATURE_MULTI_LAYER;
    UTIL_SUCCESS(ret, CyGfx_DispWinCreate(disp, &winProps, &winOrig));
    UTIL_SUCCESS(ret, CyGfx_WinSetSurface(winOrig, CYGFX_DISP_BUFF_TARGET_COLOR_BUFF, surfOrig));
    
    winProps.width = utSurfWidth(surfFilter);
    winProps.height = utSurfHeight(surfFilter);
    winProps.topLeftX = utSurfWidth(surfFilter);
    winProps.topLeftY = 0;
    winProps.layerId = CYGFX_DISP_LAYER_1;
    winProps.features = CYGFX_DISP_FEATURE_MULTI_LAYER;
    UTIL_SUCCESS(ret, CyGfx_DispWinCreate(disp, &winProps, &winFilter));
    UTIL_SUCCESS(ret, CyGfx_WinSetSurface(winFilter, CYGFX_DISP_BUFF_TARGET_COLOR_BUFF, surfFilter));
    
    winProps.width = utSurfWidth(surfText);
    winProps.height = DISPLAY_HEIGHT - utSurfHeight(surfOrig);
    winProps.topLeftX = 0;
    winProps.topLeftY = utSurfHeight(surfOrig);
    winProps.layerId = CYGFX_DISP_LAYER_2;
    UTIL_SUCCESS(ret, CyGfx_DispWinCreate(disp, &winProps, &winText));
    UTIL_SUCCESS(ret, CyGfx_WinSetSurface(winText, CYGFX_DISP_BUFF_TARGET_COLOR_BUFF, surfText));
    
    /* Commit all windows via disp commit and wait */
    CyGfx_DispCommit(disp);
    CyGfx_DispGetSync(disp, &sync);
    while(CyGfx_SyncWaitSync(&sync, 0) == CYGFX_ERP_ERR_SYNC_TIMEOUT);
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: filterApply
 * Summary:
 *  Applies the filter with specified properties on the image
 * Parameters:
 *  taps            amount of taps
 *  coefficients    coefficients of filter
 *  normalize       shall the coefficients be normalized
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR filterApply(const CYGFX_U08 taps, const CYGFX_FLOAT* const coefficients, const CYGFX_BOOL normalize)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_SRC, surfOrig));
    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_DST | CYGFX_BE_TARGET_STORE, surfFilter));
    UTIL_SUCCESS(ret, utFilterFree(ctx));
    switch (filterDir)
    {
        case 0: UTIL_SUCCESS(ret, utFilterSetFilter(ctx, CYGFX_CM_FILTER_CHANNEL_RGB, taps, coefficients, taps, coefficients, normalize)); break;
        case 1: UTIL_SUCCESS(ret, utFilterSetFilter(ctx, CYGFX_CM_FILTER_CHANNEL_RGB, taps, coefficients, 0, NULL, normalize)); break;
        case 2: UTIL_SUCCESS(ret, utFilterSetFilter(ctx, CYGFX_CM_FILTER_CHANNEL_RGB, 0, NULL, taps, coefficients, normalize)); break;
        default: UTIL_SUCCESS(ret, utFilterSetFilter(ctx, CYGFX_CM_FILTER_CHANNEL_RGB, taps, coefficients, taps, coefficients, normalize)); break;
    }
    UTIL_SUCCESS(ret, CyGfx_BeBlt(ctx, 0.f, 0.f));
    
    return ret;   
}

/**********************************************************************************************************************
 * Function Name: filterBlur
 * Summary:
 *  Calculates Gaussian blur filter and applies it
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR filterBlur(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    CYGFX_FLOAT coefficients[15];

    calcGauss(coefficients, taps, sigma);

    UTIL_SUCCESS(ret, filterApply(taps, coefficients, CYGFX_TRUE));

    UTIL_SUCCESS(ret, printInfo("Gaussian Blur", taps, sigma, coefficients));
    
    return ret;    
}

/**********************************************************************************************************************
 * Function Name: filterSharpen
 * Summary:
 *  Calculates Gaussian sharpen filter and applies it
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR filterSharpen(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    CYGFX_FLOAT coefficients[15];

    calcGauss(coefficients, taps, sigma);
    CYGFX_U08 taps_mid = (taps - 1) >> 1;
    for (int i = 0; i < taps; i++)
    {
        coefficients[i] = -coefficients[i];
        if (i == taps_mid)
        {
            coefficients[i] += 2.0f;
        }
    }

    UTIL_SUCCESS(ret, filterApply(taps, coefficients, CYGFX_TRUE));

    UTIL_SUCCESS(ret, printInfo("Gaussian Sharpen", taps, sigma, coefficients));
    
    return ret;   
}

/**********************************************************************************************************************
 * Function Name: filterEdgeDetection
 * Summary:
 *  Applies a Sobel edge detection filter
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR filterEdgeDetection(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    CYGFX_FLOAT coefficients[3] = { -1.f, 0.f, 1.f };

    UTIL_SUCCESS(ret, filterApply(3, coefficients, CYGFX_FALSE));

    UTIL_SUCCESS(ret, printInfo("Edge Detection (Sobel)", 3, -1.f, coefficients));
    
    return ret;    
}

/**********************************************************************************************************************
 * Function Name: printInfo
 * Summary:
 *  Prints information about current filter in bottom part of display.
 * Parameters:
 *  title           title to print (most likely name of filter)
 *  taps            amount of taps
 *  sigma           sigma value to print. Values smaller 0 are not printed
 *  coefficients    coefficients of filter
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR printInfo(char* title, const CYGFX_U08 taps, const CYGFX_FLOAT sigma, const CYGFX_FLOAT* const coefficients)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    char buffer[100];
    
    /* Clear previous text*/
    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_DST | CYGFX_BE_TARGET_STORE, surfText));
    UTIL_SUCCESS(ret, CyGfx_BeSetAttribute(ctx, CYGFX_BE_CTX_ATTR_COLOR, CYGFX_SM_COLOR_TO_RGBA(0, 0, 0, 255)));
    UTIL_SUCCESS(ret, CyGfx_BeFill(ctx, 0, 0, utSurfWidth(surfText), utSurfHeight(surfText)));

    /* Print title */
    UTIL_SUCCESS(ret, utTextOut(&utCtx, 0, utSurfHeight(surfText) - 12, title));
    
    /* Print number of taps */
    sprintf(buffer, "Taps: %d", taps);
    UTIL_SUCCESS(ret, utTextOut(&utCtx, 0, utSurfHeight(surfText) - 24, buffer));

    /* Print sigma value if needed */
    if (sigma >= 0.f)
    {
        sprintf(buffer, "Sigma: %.2f", sigma);
        UTIL_SUCCESS(ret, utTextOut(&utCtx, 0, utSurfHeight(surfText) - 36, buffer));
    }

    /* Print the filter coefficient
     * Since a 15 tap filter (with negative numbers) will be too wide to print in one line,
     * this function splits the rendering at KERNEL_DRAW_SPLIT if necessary. More than two
     * lines will never be printed. 
     */
    const int KERNEL_DRAW_SPLIT = 7;

    if (taps <= KERNEL_DRAW_SPLIT)
    {
        char tmp[10];
        sprintf(buffer, "[%.3f", coefficients[0]);
        for (int i = 1; i < taps; ++i)
        {
            strcat(buffer, ", ");
            sprintf(tmp, "%.3f", coefficients[i]);
            strcat(buffer, tmp);
        }
        strcat(buffer, "]");

        UTIL_SUCCESS(ret, utTextOut(&utCtx, 0, utSurfHeight(surfText) - 48, buffer));
    }
    else    /* string has to be printed on 2 lines */
    {
        /* line 1 */
        char tmp[10];
        sprintf(buffer, "[%.3f", coefficients[0]);
        for (int i = 1; i < KERNEL_DRAW_SPLIT; ++i)
        {
            strcat(buffer, ", ");
            sprintf(tmp, "%.3f", coefficients[i]);
            strcat(buffer, tmp);
        }
        strcat(buffer, ",");
        UTIL_SUCCESS(ret, utTextOut(&utCtx, 0, utSurfHeight(surfText) - 48, buffer));

        /* line 2 */
        sprintf(buffer, " %.3f", coefficients[KERNEL_DRAW_SPLIT]);
        for (int i = KERNEL_DRAW_SPLIT + 1; i < taps; ++i)
        {
            strcat(buffer, ", ");
            sprintf(tmp, "%.3f", coefficients[i]);
            strcat(buffer, tmp);
        }
        strcat(buffer, "]");
        UTIL_SUCCESS(ret, utTextOut(&utCtx, 0, utSurfHeight(surfText) - 60, buffer));
    }

    /* Print the kernel direction at the bottom */
    switch (filterDir)
    {
        case 0: sprintf(buffer, "Horizontal and vertical kernel"); break;
        case 1: sprintf(buffer, "Horizontal kernel"); break;
        case 2: sprintf(buffer, "Vertical kernel"); break;
        default: sprintf(buffer, "Horizontal and vertical kernel"); break;
    }
    UTIL_SUCCESS(ret, utTextOut(&utCtx, 0, 0, buffer));
    
    return ret;    
}

/**********************************************************************************************************************
 * Function Name: calcGauss
 * Summary:
 *  Calculates values of a Gaussian bell curve. Values are used to calculate blur and sharpen filter.
 *  Taken from util library.
 * Parameters:
 *  coefficients    array to store result
 *  taps            amount of taps
 *  sigma           sigma value to use
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void calcGauss(CYGFX_FLOAT* const coefficients, const CYGFX_U08 taps, const CYGFX_FLOAT sigma)
{
    CYGFX_S32 i;
    CYGFX_FLOAT d, d1, d2, val, sum, fexp;
    CYGFX_FLOAT PI = atanf(1.0f)*4.0f;

    d = sigma;
    d1 = 1 / (d * sqrtf(2*PI));
    d2 = 2 * d * d;
    sum = 0;
    for (i = 0; i < taps; i++)
    {
        CYGFX_U08 taps_mid = (taps - 1) >> 1;
        fexp = (CYGFX_FLOAT) (((i - taps_mid) * (i - taps_mid))) / d2;
        /* restrict size otherwise we get a nan for different compilers / HW */
        if (fexp > 32)
        {
            val = 0.0f;
        }
        else
        {
            val = expf(-fexp) * d1;
        }
        coefficients[i] = (CYGFX_FLOAT) val;
        sum += val;
    }
}
