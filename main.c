/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cy_pdl.h"
#include "cybsp.h"
#include "cy_retarget_io.h"
#include "mtb_hal.h"

#include "cygfx_driver_api.h"

#include "gfx_env.h"
#include "gfx.h"

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
/* For the Retarget -IO (Debug UART) usage */
static cy_stc_scb_uart_context_t    UART_context;           /** UART context */
static mtb_hal_uart_t               UART_hal_obj;           /** Debug UART HAL object  */

/* Interrupt configs */
const cy_stc_sysint_t INTR_CFG_USER_BTNS =
{
    .intrSrc = ((NvicMux2_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | CYBSP_USER_BTN1_IRQ),
    .intrPriority = 7UL
};

const cy_stc_sysint_t INTR_CFG_TIMER_LED =
{
    .intrSrc = ((NvicMux2_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | TIMER_LED_IRQ),
    .intrPriority = 7UL
};

const cy_stc_sysint_t INTR_CFG_TIMER_BTN1 =
{
    .intrSrc = ((NvicMux2_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | TIMER_BTN1_IRQ),
    .intrPriority = 7UL
};

const cy_stc_sysint_t INTR_CFG_TIMER_BTN2 =
{
    .intrSrc = ((NvicMux2_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | TIMER_BTN2_IRQ),
    .intrPriority = 7UL
};

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void isrUserButtons(void);
static void isrTimerLed(void);
static void isrTimerBtn1(void);
static void isrTimerBtn2(void);

static bool checkBtn(const uint32_t btnLvl, TCPWM_Type* timerHW, const unsigned long timerNum);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  Intializes board (clocks, pins, interrupts, etc.). Further enables USB-UART.
 *  Configures interrupts.
 *  Initializes graphics related parts.
 *  Periodically calls the graphics code to render a new frame when possible.
 * Parameters:
 *  none
 * Return:
 *  int error code, not used here
 **********************************************************************************************************************
 */
int main(void)
{
    cy_rslt_t result;
    CYGFX_ERROR gfxErr = CYGFX_OK;

    /* Initialize the device and board peripherals */
    result = cybsp_init();
    
    /* Board init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Enable global interrupts */
    __enable_irq();

    /* Debug UART init */
    result = (cy_rslt_t)Cy_SCB_UART_Init(UART_HW, &UART_config, &UART_context);

    /* UART init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    Cy_SCB_UART_Enable(UART_HW);

    /* Setup the HAL UART */
    result = mtb_hal_uart_setup(&UART_hal_obj, &UART_hal_config, &UART_context, NULL);

    /* HAL UART init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    result = cy_retarget_io_init(&UART_hal_obj);

    /* HAL retarget_io init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    printf("\x1b[2J\x1b[;H");

    printf("****************** "
           "GFX: FIR filter Example "
           "****************** \r\n\n");

    printf("For more projects, "
           "visit our code examples repositories:\r\n\n");

    printf("https://github.com/Infineon/"
           "Code-Examples-for-ModusToolbox-Software\r\n\n");
    
    /* Initialize user buttons */
    Cy_GPIO_SetInterruptEdge(CYBSP_USER_BTN1_PORT, CYBSP_USER_BTN1_PIN, CY_GPIO_INTR_BOTH);
    Cy_GPIO_SetInterruptMask(CYBSP_USER_BTN1_PORT, CYBSP_USER_BTN1_PIN, CY_GPIO_INTR_EN_MASK);
    Cy_GPIO_SetInterruptEdge(CYBSP_USER_BTN2_PORT, CYBSP_USER_BTN2_PIN, CY_GPIO_INTR_BOTH);
    Cy_GPIO_SetInterruptMask(CYBSP_USER_BTN2_PORT, CYBSP_USER_BTN2_PIN, CY_GPIO_INTR_EN_MASK);
    if (Cy_SysInt_Init(&INTR_CFG_USER_BTNS, isrUserButtons) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    /* Initialize timer to toggle LED */
    if (Cy_TCPWM_Counter_Init(TIMER_LED_HW, TIMER_LED_NUM, &TIMER_LED_config) != CY_TCPWM_SUCCESS)
    {
        CY_ASSERT(0);
    }
    if (Cy_SysInt_Init(&INTR_CFG_TIMER_LED, &isrTimerLed) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    /* Initialize timer for detecting if button 1 is held */
    if (Cy_TCPWM_Counter_Init(TIMER_BTN1_HW, TIMER_BTN1_NUM, &TIMER_BTN1_config) != CY_TCPWM_SUCCESS)
    {
        CY_ASSERT(0);
    }
    if (Cy_SysInt_Init(&INTR_CFG_TIMER_BTN1, &isrTimerBtn1) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    /* Initialize timer for detecting if button 2 is held */
    if (Cy_TCPWM_Counter_Init(TIMER_BTN2_HW, TIMER_BTN2_NUM, &TIMER_BTN2_config) != CY_TCPWM_SUCCESS)
    {
        CY_ASSERT(0);
    }
    if (Cy_SysInt_Init(&INTR_CFG_TIMER_BTN2, &isrTimerBtn2) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    /* Enable IRQ on NVIC. Every peripheral is mapped to NvicMux2 */
    NVIC_ClearPendingIRQ((IRQn_Type) NvicMux2_IRQn);
    NVIC_EnableIRQ((IRQn_Type) NvicMux2_IRQn);
    
    /* Start the blinking LED */
    Cy_TCPWM_Counter_Enable(TIMER_LED_HW, TIMER_LED_NUM);
    Cy_TCPWM_TriggerStart_Single(TIMER_LED_HW, TIMER_LED_NUM);
    
    /* Initialize graphics related parts */
    prepareGfx();
    gfxErr = initGfx();

    /* Main application */
    while(gfxErr == CYGFX_OK)
    {   
        gfxErr = loopGfx();
    }
    
    /* If for whatever reason application closes unexpectedly, deinitialize properly. */
    deinitGfx();
}

/**********************************************************************************************************************
 * Function Name: isrUserButtons
 * Summary:
 *  Interrupt service routine for the user buttons. Checks if button is pressed or held,
 *  takes care of starting/checking the respective timer for this.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void isrUserButtons(void)
{
    uint32_t btn1Lvl = Cy_GPIO_Read(CYBSP_USER_BTN1_PORT, CYBSP_USER_BTN1_PIN);
    uint32_t btn2Lvl = Cy_GPIO_Read(CYBSP_USER_BTN2_PORT, CYBSP_USER_BTN2_PIN);
    
    uint32_t irqButton1 = Cy_GPIO_GetInterruptStatusMasked(CYBSP_USER_BTN1_PORT, CYBSP_USER_BTN1_PIN);
    uint32_t irqButton2 = Cy_GPIO_GetInterruptStatusMasked(CYBSP_USER_BTN2_PORT, CYBSP_USER_BTN2_PIN);
    
    
    if (irqButton1)
    {
        if (checkBtn(btn1Lvl, TIMER_BTN1_HW, TIMER_BTN1_NUM) == true)
        {
            nextTaps();
        }

        Cy_GPIO_ClearInterrupt(CYBSP_USER_BTN1_PORT, CYBSP_USER_BTN1_PIN);
    }
    
    if (irqButton2)
    {
        if (checkBtn(btn2Lvl, TIMER_BTN2_HW, TIMER_BTN2_NUM) == true)
        {
            nextSigma();
        }
      
        Cy_GPIO_ClearInterrupt(CYBSP_USER_BTN2_PORT, CYBSP_USER_BTN2_PIN);
    }
}

/**********************************************************************************************************************
 * Function Name: isrTimerLed
 * Summary:
 *  Interrupt service routine for LED timer. Toggles LED.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void isrTimerLed(void)
{
    /* Get interrupt source */
    uint32_t intrMask = Cy_TCPWM_GetInterruptStatusMasked(TIMER_LED_HW, TIMER_LED_NUM);
    
    /* Invert LED */
    Cy_GPIO_Inv(CYBSP_USER_LED1_PORT, CYBSP_USER_LED1_PIN);

    /* Clear interrupt source */
    Cy_TCPWM_ClearInterrupt(TIMER_LED_HW, TIMER_LED_NUM, intrMask);    
}

/**********************************************************************************************************************
 * Function Name: isrTimerBtn1
 * Summary:
 *  Timer for User Button 1 which is triggered when the button is held long enough. Changes respective property.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void isrTimerBtn1(void)
{
    /* Get interrupt source */
    uint32_t intrMask = Cy_TCPWM_GetInterruptStatusMasked(TIMER_BTN1_HW, TIMER_BTN1_NUM);
    
    nextFilter();

    /* Clear interrupt source */
    Cy_TCPWM_ClearInterrupt(TIMER_BTN1_HW, TIMER_BTN1_NUM, intrMask);    
}

/**********************************************************************************************************************
 * Function Name: isrTimerBtn2
 * Summary:
 *  Timer for User Button 2 which is triggered when the button is held long enough. Changes respective property.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void isrTimerBtn2(void)
{
    /* Get interrupt source */
    uint32_t intrMask = Cy_TCPWM_GetInterruptStatusMasked(TIMER_BTN2_HW, TIMER_BTN2_NUM);

    nextDirection();
    
    /* Clear interrupt source */
    Cy_TCPWM_ClearInterrupt(TIMER_BTN2_HW, TIMER_BTN2_NUM, intrMask);        
}

/**********************************************************************************************************************
 * Function Name: checkBtn
 * Summary:
 *  Helper function for button ISR which checks and manages if the button is pressed or held.
 * Parameters:
 *  btnLvl    is the button high or low when the ISR is called
 *  timerHW   timer module from TCPWM corresponding to the button to indicate if held long enough
 *  timerNum  timer number from the respective timer module
 * Return:
 *  bool returns true if the button is definitely only pressed, else false
 **********************************************************************************************************************
 */
static bool checkBtn(const uint32_t btnLvl, TCPWM_Type* timerHW, const unsigned long timerNum)
{
    /* Button was pressed, start a timer to check if the button will be held */
    if (btnLvl == 0)
    {
        Cy_TCPWM_Counter_SetCounter(timerHW, timerNum, 0);
        Cy_TCPWM_Counter_Enable(timerHW, timerNum);
        Cy_TCPWM_TriggerStart_Single(timerHW, timerNum);
    }
    else /* Button was released */
    {
        uint32_t timerStatus = Cy_TCPWM_Counter_GetStatus(timerHW, timerNum);
        
        /* Button was released while timer still running, thus button is pressed not held */
        if (timerStatus & CY_TCPWM_COUNTER_STATUS_COUNTER_RUNNING)
        {
            Cy_TCPWM_TriggerStopOrKill_Single(timerHW, timerNum);
            Cy_TCPWM_Counter_Disable(timerHW, timerNum);
            return true;
        }
        /* Else if timer not running, the timer ISR will do the respective action, nothing to be done here */
    }
    
    return false;
}

/* [] END OF FILE */
